# 算法基础

## 二分查找

```c
void Binaryserch(int*nums, int numsSize, int target){
    int left = 0;
    int right = numsSize - 1;
    while(left <= right){
        int mid = (right - left) >> 1 + left;
        if (nums[mid] == target){
            printf("找到了， 下标为%d\n", mid);
            return ;
        }
        else if(nums[mid] > target){
            right = mid - 1;
        }
        else{
            left = mid +1;
        }
        printf("没有要找的值\n");
    }
}
```

### 习题 1

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。  
测试用例：
>示例1：  
输入：n=6,nums=[-1,0,3,5,9,12],target=9  
输出:4  
示例2：
输入：n=6,nums=[-1,0,3,5,9,12],target=2  
输出：-1

```C
int Bin(int* arr, int n, int target){
    int left = 0;
    int right = n - 1;
    while(left <= right){
        int mid = (right - left) / 2 + left;
        if(arr[mid] == target){
            return mid;
        }
        else if(arr[mid] < target){
            left = mid + 1;
        }
        else{
            right = mid - 1;
        }
    }
    return -1;
}
```

1. 有一个有序表为1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50当二分查找值为48的结点时，查找成功需要比较的次数是<u>&emsp;2&emsp;</u>
2. 设某算法的递推公式是$T(n)=T(n-1)+n, T(0)=1$, 则求该算法第n项的时间复杂度为<u>&emsp;O(n)&emsp;</u>
3. 设n是描述问题规模的非负整数，下列程序段的时间复杂度是多少（B）

 ```c
x=0;
while(n>=(x+1)*(x+1))
x=x+1;
```

 A. $O(logn)$    B. $O(n^{1/2})$   C. $O(n)$    D. $O(n^{2})$

 1. 分析下面程序段的时间复杂度 $O(n^2)$

 ```c
 m=0;
for (i=1; i<n; i++)
    for (j=1; j<=n-i; j++)
        m=m+1;
 ```

5. 分析下面程序段的时间复杂度 $O(nlogn)$

 ```c
 for(i=0; i<n; i++)
  for(j=i; j>0; j/=2)
     printf(“%d\n”, j);
 ```

### 习题 2

题目描述：  
输入n单调递增的（就是后面的数字不小于前面的数字）非负整数a1, a2,.. . , an，然后进行m次询问。对于每次询问，给出一个整数q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出-1。  
输入格式  
第一行2个整数n和m，表示数字个数和询问次数。  
第二行n个整数，表示这些待查询的数字。  
第三行m个整数，表示询问这些数字的编号，从1开始编号。  
输出格式  
m个整数表示答案。  
>注：要求定义长度为n的数组

```c
#include <stdio.h>
#include <stdlib.h>

int binSearch(int *nums, int left, int right, int target) {
    int mid = (left + right) >> 1;
    if (left > right) {
        return -1;
    }
    if (nums[mid] == target) {
        while (mid > 0 && nums[mid - 1] == nums[mid]) {
            mid--;
        }
        return mid + 1;
    } else if (nums[mid] > target) {
        return binSearch(nums, left, mid - 1, target);
    } else {
        return binSearch(nums, left + 1, right, target);
    }
    return -2;
}

int main() {
    int n;
    scanf("%d", &n);
    int *nums = (int *)malloc(sizeof(int) * n);
    int m;
    scanf("%d", &m);
    for (int i = 0; i < n; i++) {
        scanf("%d", (nums + i));
    }
    for (int i = 0; i < m; i++) {
        int target;
        scanf("%d", &target);
        printf("%d ", binSearch(nums, 0, n - 1, target));
    }
    free(nums);
    return 0;
}
```

### 习题3

>木材厂有一些原木,现在想把这些木头切割成一些长度相同的小段木头,需要得到的小段的数目是给定的。当然,我们希望得到的小段越长越好,你的任务是计算能够得到的小段木头的最大长度。木头长度的单位是 cm。原木的长度都是正整数,我们要求切割得到的小段木头的长度也是正整数。

### 丢失的数字

#### 方法1

```c
#include <stdio.h>
#include <stdlib.h>

int find(int *arr, int n){
    int sum = n * (n + 1) / 2;
    for (int i = 0; i < n;i++){
        sum -= arr[i];
    }
    return sum;
}

int main() {
    int n;
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);
    for (int i = 0; i < n;i++){
        scanf("%d", &arr[i]);
    }
    int k = find(arr, n);
    free(arr);
    return 0;
}
```

#### 方法2

```c

#include <stdio.h>
#include <stdlib.h>

void swap(int *n1,int *n2){
    int tmp = *n1;
    *n1 = *n2;
    *n2 = tmp;
}

void bubble_sort(int *nums, int numsSize){
    for (int i = 0; i < numsSize - 1;i++){
        for (int j = 0; j < numsSize - i - 1;j++){
            int flag = 1;
            if(nums[j] > nums[j+1]){
                swap(&nums[j], &nums[j + 1]);
                flag = 0;
            }
            if(flag){
                return;
            }
        }
    }
}

int find(int *nums, int n){
    for (int i = 0; i < n;i++){
        if(nums[i] != i){
            return i;
        }
    }
    return n;
}

int main() {
    int n;
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);
    for (int i = 0; i < n;i++){
        scanf("%d", &arr[i]);
    }
    bubble_sort(arr, n);
    int k = find(arr, n);
    printf("%d", k);
    free(arr);
    return 0;
}```

## 算法的时间复杂度

### 大(O)表示法

#### 推导方法

1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且系数不是1，则去除与这个常数

##### 常数阶

##### 线性阶

##### 对数阶

##### 平方阶

循环嵌套

### 一些常见的大O运行时间

+ O($log_{}{n}$)
+ O($n$)
+ O($n*log_{}{n}$)
+ O(${n}^{2}$)
+ O($n!$)

## 排序算法

### 冒泡排序

```c
void bubble_sort(int *nums, int numsSize){
    for (int i = 0; i < numsSize - 1;i++){
        for (int j = 0; j < numsSize -i - 1;j++){
            int flag = 1;
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                flag = 0;
            }
            if(flag){
                return;
            }
        }
    }
}
```
